/* tslint:disable */
/* eslint-disable */
/**
 * Fulfillment Management
 * With Walmart Fulfillment Services, you can focus on sales while we expertly take care of fast shipping, seamless returns, and customer service. Simply send your inventory to Walmart fulfillment centers, where we will store your products securely and prepare them swiftly for shipping when an order is placed.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface Cause
 */
export interface Cause {
  /**
   *
   * @type {string}
   * @memberof Cause
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof Cause
   */
  field?: string;
  /**
   *
   * @type {string}
   * @memberof Cause
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof Cause
   */
  description?: string;
}
/**
 *
 * @export
 * @interface FeedId
 */
export interface FeedId {
  /**
   * A unique ID, returned from the Bulk Upload API, used for tracking the feed file
   * @type {string}
   * @memberof FeedId
   */
  feedId?: string;
  /**
   *
   * @type {object}
   * @memberof FeedId
   */
  additionalAttributes?: object;
  /**
   *
   * @type {object}
   * @memberof FeedId
   */
  errors?: object;
}
/**
 *
 * @export
 * @interface GetShipmentItemsDTO
 */
export interface GetShipmentItemsDTO {
  /**
   *
   * @type {InlineResponse200Headers}
   * @memberof GetShipmentItemsDTO
   */
  headers?: InlineResponse200Headers;
  /**
   * response payload
   * @type {Array<InlineResponse2005Payload>}
   * @memberof GetShipmentItemsDTO
   */
  payload?: Array<InlineResponse2005Payload>;
}
/**
 *
 * @export
 * @interface GetShipmentPlanDTO
 */
export interface GetShipmentPlanDTO {
  /**
   *
   * @type {InlineResponse200Headers}
   * @memberof GetShipmentPlanDTO
   */
  headers?: InlineResponse200Headers;
  /**
   * response payload
   * @type {Array<InlineResponse200Payload>}
   * @memberof GetShipmentPlanDTO
   */
  payload?: Array<InlineResponse200Payload>;
}
/**
 *
 * @export
 * @interface Headers
 */
export interface Headers {
  /**
   * total number of POs for provided GET request.
   * @type {number}
   * @memberof Headers
   */
  totalCount?: number;
  /**
   * provided limit value in the request
   * @type {number}
   * @memberof Headers
   */
  limit?: number;
  /**
   * provided offset value in the request.
   * @type {number}
   * @memberof Headers
   */
  offset?: number;
}
/**
 * response payload
 * @export
 * @interface InboundShipmentCreateResponseWrapper
 */
export interface InboundShipmentCreateResponseWrapper {
  /**
   * Unique ID identifying each shipment
   * @type {string}
   * @memberof InboundShipmentCreateResponseWrapper
   */
  shipmentId?: string;
  /**
   *
   * @type {InlineResponse200ShipToAddress}
   * @memberof InboundShipmentCreateResponseWrapper
   */
  shipToAddress?: InlineResponse200ShipToAddress;
  /**
   * The items which needs to be send in the shipment
   * @type {Array<InlineResponse2001ShipmentItems>}
   * @memberof InboundShipmentCreateResponseWrapper
   */
  shipmentItems?: Array<InlineResponse2001ShipmentItems>;
  /**
   * expected delivery date for inbounding shipment. Can be different from provided in the rquest based on network capacity
   * @type {string}
   * @memberof InboundShipmentCreateResponseWrapper
   */
  expectedDeliveryDate?: string;
}
/**
 *
 * @export
 * @interface InboundShipmentCreateResponseWrapperDTO
 */
export interface InboundShipmentCreateResponseWrapperDTO {
  /**
   *
   * @type {string}
   * @memberof InboundShipmentCreateResponseWrapperDTO
   */
  status?: string;
  /**
   * response payload
   * @type {Array<InlineResponse2001Payload>}
   * @memberof InboundShipmentCreateResponseWrapperDTO
   */
  payload?: Array<InlineResponse2001Payload>;
}
/**
 *
 * @export
 * @interface InboundShipmentErrorResponseWrapperDTO
 */
export interface InboundShipmentErrorResponseWrapperDTO {
  /**
   *
   * @type {InlineResponse200Headers}
   * @memberof InboundShipmentErrorResponseWrapperDTO
   */
  headers?: InlineResponse200Headers;
  /**
   * response payload
   * @type {Array<InlineResponse2004Payload>}
   * @memberof InboundShipmentErrorResponseWrapperDTO
   */
  payload?: Array<InlineResponse2004Payload>;
}
/**
 * response payload
 * @export
 * @interface InboundShipmentErrorsResponseWrapper
 */
export interface InboundShipmentErrorsResponseWrapper {
  /**
   * Unique ID identifying inbound shipment requests
   * @type {string}
   * @memberof InboundShipmentErrorsResponseWrapper
   */
  inboundOrderId?: string;
  /**
   * created date for the request
   * @type {string}
   * @memberof InboundShipmentErrorsResponseWrapper
   */
  createdDate?: string;
  /**
   *
   * @type {InlineResponse200ReturnAddress}
   * @memberof InboundShipmentErrorsResponseWrapper
   */
  returnAddress?: InlineResponse200ReturnAddress;
  /**
   * inbound shipment request line items
   * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
   * @memberof InboundShipmentErrorsResponseWrapper
   */
  orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
  /**
   * Error in inbound shipment creation
   * @type {Array<InlineResponse2002Errors>}
   * @memberof InboundShipmentErrorsResponseWrapper
   */
  errors?: Array<InlineResponse2002Errors>;
}
/**
 *
 * @export
 * @interface InboundShipmentRequestWrapper
 */
export interface InboundShipmentRequestWrapper {
  /**
   * Unique ID identifying inbound shipment request
   * @type {string}
   * @memberof InboundShipmentRequestWrapper
   */
  inboundOrderId: string;
  /**
   *
   * @type {InlineResponse200ReturnAddress}
   * @memberof InboundShipmentRequestWrapper
   */
  returnAddress: InlineResponse200ReturnAddress;
  /**
   * inbound shipment request line items
   * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
   * @memberof InboundShipmentRequestWrapper
   */
  orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
}
/**
 *
 * @export
 * @interface InboundShipmentUpdateQtyWrapper
 */
export interface InboundShipmentUpdateQtyWrapper {
  /**
   * Unique ID identifying inbound shipment request
   * @type {string}
   * @memberof InboundShipmentUpdateQtyWrapper
   */
  inboundOrderId: string;
  /**
   * Unique ID identifying inbound shipment
   * @type {string}
   * @memberof InboundShipmentUpdateQtyWrapper
   */
  shipmentId: string;
  /**
   * update shipment qty line items
   * @type {Array<V3FulfillmentShipmentQuantitiesOrderItems>}
   * @memberof InboundShipmentUpdateQtyWrapper
   */
  orderItems?: Array<V3FulfillmentShipmentQuantitiesOrderItems>;
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   * Unique ID identifying inbound shipment request
   * @type {string}
   * @memberof InlineObject
   */
  inboundOrderId: string;
  /**
   *
   * @type {InlineResponse200ReturnAddress}
   * @memberof InlineObject
   */
  returnAddress: InlineResponse200ReturnAddress;
  /**
   * inbound shipment request line items
   * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
   * @memberof InlineObject
   */
  orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
}
/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  shipmentId: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  carrierName: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject1
   */
  trackingInfo?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
  /**
   *
   * @type {any}
   * @memberof InlineObject2
   */
  file?: any;
}
/**
 *
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
  /**
   * Unique ID identifying inbound shipment request
   * @type {string}
   * @memberof InlineObject3
   */
  inboundOrderId: string;
  /**
   * Unique ID identifying inbound shipment
   * @type {string}
   * @memberof InlineObject3
   */
  shipmentId: string;
  /**
   * update shipment qty line items
   * @type {Array<V3FulfillmentShipmentQuantitiesOrderItems>}
   * @memberof InlineObject3
   */
  orderItems?: Array<V3FulfillmentShipmentQuantitiesOrderItems>;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {InlineResponse200Headers}
   * @memberof InlineResponse200
   */
  headers?: InlineResponse200Headers;
  /**
   * response payload
   * @type {Array<InlineResponse200Payload>}
   * @memberof InlineResponse200
   */
  payload?: Array<InlineResponse200Payload>;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2001
   */
  status?: string;
  /**
   * response payload
   * @type {Array<InlineResponse2001Payload>}
   * @memberof InlineResponse2001
   */
  payload?: Array<InlineResponse2001Payload>;
}
/**
 * response payload
 * @export
 * @interface InlineResponse2001Payload
 */
export interface InlineResponse2001Payload {
  /**
   * Unique ID identifying each shipment
   * @type {string}
   * @memberof InlineResponse2001Payload
   */
  shipmentId?: string;
  /**
   *
   * @type {InlineResponse200ShipToAddress}
   * @memberof InlineResponse2001Payload
   */
  shipToAddress?: InlineResponse200ShipToAddress;
  /**
   * The items which needs to be send in the shipment
   * @type {Array<InlineResponse2001ShipmentItems>}
   * @memberof InlineResponse2001Payload
   */
  shipmentItems?: Array<InlineResponse2001ShipmentItems>;
  /**
   * expected delivery date for inbounding shipment. Can be different from provided in the rquest based on network capacity
   * @type {string}
   * @memberof InlineResponse2001Payload
   */
  expectedDeliveryDate?: string;
}
/**
 * The items which needs to be send in the shipment
 * @export
 * @interface InlineResponse2001ShipmentItems
 */
export interface InlineResponse2001ShipmentItems {
  /**
   * Seller Item ID
   * @type {string}
   * @memberof InlineResponse2001ShipmentItems
   */
  vendorSku?: string;
  /**
   * Total number of sellable units
   * @type {number}
   * @memberof InlineResponse2001ShipmentItems
   */
  itemQty?: number;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002
   */
  status: InlineResponse2002StatusEnum;
  /**
   *
   * @type {InlineResponse2002Header}
   * @memberof InlineResponse2002
   */
  header?: InlineResponse2002Header;
  /**
   *
   * @type {Array<InlineResponse2002Errors>}
   * @memberof InlineResponse2002
   */
  errors?: Array<InlineResponse2002Errors>;
  /**
   *
   * @type {object}
   * @memberof InlineResponse2002
   */
  payload?: object;
}

/**
 * @export
 * @enum {string}
 */
export enum InlineResponse2002StatusEnum {
  Ok = "OK",
  Created = "CREATED",
  Accepted = "ACCEPTED",
  NoContent = "NO_CONTENT",
  Partial = "PARTIAL",
  MovedPermanent = "MOVED_PERMANENT",
  Found = "FOUND",
  SeeOther = "SEE_OTHER",
  NotModified = "NOT_MODIFIED",
  TemporaryRedirect = "TEMPORARY_REDIRECT",
  BadRequest = "BAD_REQUEST",
  Unauthorized = "UNAUTHORIZED",
  Forbidden = "FORBIDDEN",
  NotFound = "NOT_FOUND",
  MethodNotAllowed = "METHOD_NOT_ALLOWED",
  NotAcceptable = "NOT_ACCEPTABLE",
  RequestTimeout = "REQUEST_TIMEOUT",
  Conflict = "CONFLICT",
  RequestEntityTooLarge = "REQUEST_ENTITY_TOO_LARGE",
  UnsupportedMediaType = "UNSUPPORTED_MEDIA_TYPE",
  UnprocessableEntity = "UNPROCESSABLE_ENTITY",
  Fail = "FAIL",
  BadGateway = "BAD_GATEWAY",
  ServiceUnavailable = "SERVICE_UNAVAILABLE",
  GatewayTimeout = "GATEWAY_TIMEOUT",
}

/**
 *
 * @export
 * @interface InlineResponse2002Causes
 */
export interface InlineResponse2002Causes {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Causes
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Causes
   */
  field?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Causes
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Causes
   */
  description?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2002Errors
 */
export interface InlineResponse2002Errors {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Errors
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Errors
   */
  field?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Errors
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Errors
   */
  info?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Errors
   */
  severity?: InlineResponse2002ErrorsSeverityEnum;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Errors
   */
  category?: InlineResponse2002ErrorsCategoryEnum;
  /**
   *
   * @type {Array<InlineResponse2002Causes>}
   * @memberof InlineResponse2002Errors
   */
  causes?: Array<InlineResponse2002Causes>;
}

/**
 * @export
 * @enum {string}
 */
export enum InlineResponse2002ErrorsSeverityEnum {
  Info = "INFO",
  Warn = "WARN",
  Error = "ERROR",
}
/**
 * @export
 * @enum {string}
 */
export enum InlineResponse2002ErrorsCategoryEnum {
  Application = "APPLICATION",
  System = "SYSTEM",
  Request = "REQUEST",
  Data = "DATA",
}

/**
 *
 * @export
 * @interface InlineResponse2002Header
 */
export interface InlineResponse2002Header {
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof InlineResponse2002Header
   */
  headerAttributes?: { [key: string]: object };
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   * A unique ID, returned from the Bulk Upload API, used for tracking the feed file
   * @type {string}
   * @memberof InlineResponse2003
   */
  feedId?: string;
  /**
   *
   * @type {object}
   * @memberof InlineResponse2003
   */
  additionalAttributes?: object;
  /**
   *
   * @type {object}
   * @memberof InlineResponse2003
   */
  errors?: object;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
  /**
   *
   * @type {InlineResponse200Headers}
   * @memberof InlineResponse2004
   */
  headers?: InlineResponse200Headers;
  /**
   * response payload
   * @type {Array<InlineResponse2004Payload>}
   * @memberof InlineResponse2004
   */
  payload?: Array<InlineResponse2004Payload>;
}
/**
 * response payload
 * @export
 * @interface InlineResponse2004Payload
 */
export interface InlineResponse2004Payload {
  /**
   * Unique ID identifying inbound shipment requests
   * @type {string}
   * @memberof InlineResponse2004Payload
   */
  inboundOrderId?: string;
  /**
   * created date for the request
   * @type {string}
   * @memberof InlineResponse2004Payload
   */
  createdDate?: string;
  /**
   *
   * @type {InlineResponse200ReturnAddress}
   * @memberof InlineResponse2004Payload
   */
  returnAddress?: InlineResponse200ReturnAddress;
  /**
   * inbound shipment request line items
   * @type {Array<V3FulfillmentInboundShipmentsOrderItems>}
   * @memberof InlineResponse2004Payload
   */
  orderItems?: Array<V3FulfillmentInboundShipmentsOrderItems>;
  /**
   * Error in inbound shipment creation
   * @type {Array<InlineResponse2002Errors>}
   * @memberof InlineResponse2004Payload
   */
  errors?: Array<InlineResponse2002Errors>;
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
  /**
   *
   * @type {InlineResponse200Headers}
   * @memberof InlineResponse2005
   */
  headers?: InlineResponse200Headers;
  /**
   * response payload
   * @type {Array<InlineResponse2005Payload>}
   * @memberof InlineResponse2005
   */
  payload?: Array<InlineResponse2005Payload>;
}
/**
 * response payload
 * @export
 * @interface InlineResponse2005Payload
 */
export interface InlineResponse2005Payload {
  /**
   * Unique ID identifying inbound shipment request
   * @type {string}
   * @memberof InlineResponse2005Payload
   */
  inboundOrderId?: string;
  /**
   * Unique ID identifying each shipment
   * @type {string}
   * @memberof InlineResponse2005Payload
   */
  shipmentId?: string;
  /**
   * Item barcode
   * @type {string}
   * @memberof InlineResponse2005Payload
   */
  gtin?: string;
  /**
   * Seller Item ID
   * @type {string}
   * @memberof InlineResponse2005Payload
   */
  sku?: string;
  /**
   * Item description
   * @type {string}
   * @memberof InlineResponse2005Payload
   */
  itemDesc?: string;
  /**
   * Total number of sellable units
   * @type {number}
   * @memberof InlineResponse2005Payload
   */
  itemQty?: number;
  /**
   * Total number of cases
   * @type {number}
   * @memberof InlineResponse2005Payload
   */
  vendorPackQty?: number;
  /**
   * Total number of sellable units per case
   * @type {number}
   * @memberof InlineResponse2005Payload
   */
  innerPackQty?: number;
  /**
   * Qty received in FC
   * @type {number}
   * @memberof InlineResponse2005Payload
   */
  receivedQty?: number;
  /**
   * Qty damaged while receiving in FC
   * @type {number}
   * @memberof InlineResponse2005Payload
   */
  damagedQty?: number;
  /**
   * Fill rate for this shipment item
   * @type {number}
   * @memberof InlineResponse2005Payload
   */
  fillRate?: number;
  /**
   * expected delivery date provided by seller
   * @type {string}
   * @memberof InlineResponse2005Payload
   */
  expectedDeliveryDate?: string;
  /**
   * update expected delivery date based on network capacity
   * @type {string}
   * @memberof InlineResponse2005Payload
   */
  updatedExpectedDeliveryDate?: string;
  /**
   * FC name
   * @type {string}
   * @memberof InlineResponse2005Payload
   */
  shipNodeName?: string;
}
/**
 *
 * @export
 * @interface InlineResponse200Headers
 */
export interface InlineResponse200Headers {
  /**
   * total number of POs for provided GET request.
   * @type {number}
   * @memberof InlineResponse200Headers
   */
  totalCount?: number;
  /**
   * provided limit value in the request
   * @type {number}
   * @memberof InlineResponse200Headers
   */
  limit?: number;
  /**
   * provided offset value in the request.
   * @type {number}
   * @memberof InlineResponse200Headers
   */
  offset?: number;
}
/**
 * response payload
 * @export
 * @interface InlineResponse200Payload
 */
export interface InlineResponse200Payload {
  /**
   * Unique ID identifying inbound shipment request
   * @type {string}
   * @memberof InlineResponse200Payload
   */
  inboundOrderId?: string;
  /**
   * Unique ID identifying inbound shipment
   * @type {string}
   * @memberof InlineResponse200Payload
   */
  shipmentId?: string;
  /**
   *
   * @type {InlineResponse200ShipToAddress}
   * @memberof InlineResponse200Payload
   */
  shipToAddress?: InlineResponse200ShipToAddress;
  /**
   *
   * @type {InlineResponse200ReturnAddress}
   * @memberof InlineResponse200Payload
   */
  returnAddress?: InlineResponse200ReturnAddress;
  /**
   * Current status of the shipment
   * @type {string}
   * @memberof InlineResponse200Payload
   */
  status?: string;
  /**
   * creation date for shipment
   * @type {string}
   * @memberof InlineResponse200Payload
   */
  createdDate?: string;
  /**
   * Total number of units in the shipment
   * @type {number}
   * @memberof InlineResponse200Payload
   */
  shipmentUnits?: number;
  /**
   * Total number of units recived in FC for the shipment
   * @type {number}
   * @memberof InlineResponse200Payload
   */
  receivedUnits?: number;
  /**
   * expected delivery date provided by seller
   * @type {string}
   * @memberof InlineResponse200Payload
   */
  expectedDeliveryDate?: string;
  /**
   * update expected delivery date based on network capacity
   * @type {string}
   * @memberof InlineResponse200Payload
   */
  updatedExpectedDeliveryDate?: string;
  /**
   * Actual delivery date of the shipment at FC
   * @type {string}
   * @memberof InlineResponse200Payload
   */
  actualDeliveryDate?: string;
  /**
   * Tracking info for the shipment
   * @type {Array<string>}
   * @memberof InlineResponse200Payload
   */
  trackingNo?: Array<string>;
  /**
   * Carrier of the shipment
   * @type {string}
   * @memberof InlineResponse200Payload
   */
  carrierName?: string;
}
/**
 * Retrun address for seller
 * @export
 * @interface InlineResponse200ReturnAddress
 */
export interface InlineResponse200ReturnAddress {
  /**
   * Address details
   * @type {string}
   * @memberof InlineResponse200ReturnAddress
   */
  addressLine1: string;
  /**
   * Address details continuation
   * @type {string}
   * @memberof InlineResponse200ReturnAddress
   */
  addressLine2: string;
  /**
   * City name
   * @type {string}
   * @memberof InlineResponse200ReturnAddress
   */
  city: string;
  /**
   * State Code
   * @type {string}
   * @memberof InlineResponse200ReturnAddress
   */
  stateCode: string;
  /**
   * Country code
   * @type {string}
   * @memberof InlineResponse200ReturnAddress
   */
  countryCode: string;
  /**
   * Zip code
   * @type {string}
   * @memberof InlineResponse200ReturnAddress
   */
  postalCode: string;
}
/**
 * The address to which sellers need to inbound items
 * @export
 * @interface InlineResponse200ShipToAddress
 */
export interface InlineResponse200ShipToAddress {
  /**
   * Facility name
   * @type {string}
   * @memberof InlineResponse200ShipToAddress
   */
  fcName?: string;
  /**
   * Address details
   * @type {string}
   * @memberof InlineResponse200ShipToAddress
   */
  addressLine1?: string;
  /**
   * Address details continuation
   * @type {string}
   * @memberof InlineResponse200ShipToAddress
   */
  addressLine2?: string;
  /**
   * City name
   * @type {string}
   * @memberof InlineResponse200ShipToAddress
   */
  city?: string;
  /**
   * State code
   * @type {string}
   * @memberof InlineResponse200ShipToAddress
   */
  stateCode?: string;
  /**
   * Country code
   * @type {string}
   * @memberof InlineResponse200ShipToAddress
   */
  countryCode?: string;
  /**
   * Zip code
   * @type {string}
   * @memberof InlineResponse200ShipToAddress
   */
  postalCode?: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  field?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  info?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  severity?: ModelErrorSeverityEnum;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  category?: ModelErrorCategoryEnum;
  /**
   *
   * @type {Array<InlineResponse2002Causes>}
   * @memberof ModelError
   */
  causes?: Array<InlineResponse2002Causes>;
}

/**
 * @export
 * @enum {string}
 */
export enum ModelErrorSeverityEnum {
  Info = "INFO",
  Warn = "WARN",
  Error = "ERROR",
}
/**
 * @export
 * @enum {string}
 */
export enum ModelErrorCategoryEnum {
  Application = "APPLICATION",
  System = "SYSTEM",
  Request = "REQUEST",
  Data = "DATA",
}

/**
 * inbound shipment request line items
 * @export
 * @interface OrderItem
 */
export interface OrderItem {
  /**
   * Unique ID identifying product
   * @type {string}
   * @memberof OrderItem
   */
  productId: string;
  /**
   * Supported product types are GTIN,UPC,EAN
   * @type {string}
   * @memberof OrderItem
   */
  productType: string;
  /**
   * Seller Item ID
   * @type {string}
   * @memberof OrderItem
   */
  sku: string;
  /**
   * Item description
   * @type {string}
   * @memberof OrderItem
   */
  itemDesc: string;
  /**
   * Total number of sellable units
   * @type {number}
   * @memberof OrderItem
   */
  itemQty: number;
  /**
   * Total number of cases
   * @type {number}
   * @memberof OrderItem
   */
  vendorPackQty: number;
  /**
   * Total number of sellable units per case
   * @type {number}
   * @memberof OrderItem
   */
  innerPackQty: number;
  /**
   * expected delivery date for shipment
   * @type {string}
   * @memberof OrderItem
   */
  expectedDeliveryDate: string;
  /**
   *
   * @type {number}
   * @memberof OrderItem
   */
  itemNbr?: number;
  /**
   *
   * @type {Array<number>}
   * @memberof OrderItem
   */
  dimensions?: Array<number>;
  /**
   *
   * @type {number}
   * @memberof OrderItem
   */
  itemWeightQty?: number;
  /**
   *
   * @type {boolean}
   * @memberof OrderItem
   */
  nonSortItem?: boolean;
  /**
   *
   * @type {string}
   * @memberof OrderItem
   */
  shipNode?: string;
}
/**
 * update shipment qty line items
 * @export
 * @interface OrderItemUpdate
 */
export interface OrderItemUpdate {
  /**
   * Seller Item ID
   * @type {string}
   * @memberof OrderItemUpdate
   */
  sku: string;
  /**
   * updated quantity
   * @type {number}
   * @memberof OrderItemUpdate
   */
  updatedShipmentQty: number;
}
/**
 * Retrun address for seller
 * @export
 * @interface ReturnAddress
 */
export interface ReturnAddress {
  /**
   * Address details
   * @type {string}
   * @memberof ReturnAddress
   */
  addressLine1: string;
  /**
   * Address details continuation
   * @type {string}
   * @memberof ReturnAddress
   */
  addressLine2: string;
  /**
   * City name
   * @type {string}
   * @memberof ReturnAddress
   */
  city: string;
  /**
   * State Code
   * @type {string}
   * @memberof ReturnAddress
   */
  stateCode: string;
  /**
   * Country code
   * @type {string}
   * @memberof ReturnAddress
   */
  countryCode: string;
  /**
   * Zip code
   * @type {string}
   * @memberof ReturnAddress
   */
  postalCode: string;
}
/**
 *
 * @export
 * @interface ServiceHeader
 */
export interface ServiceHeader {
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof ServiceHeader
   */
  headerAttributes?: { [key: string]: object };
}
/**
 *
 * @export
 * @interface ServiceResponse
 */
export interface ServiceResponse {
  /**
   *
   * @type {string}
   * @memberof ServiceResponse
   */
  status: ServiceResponseStatusEnum;
  /**
   *
   * @type {InlineResponse2002Header}
   * @memberof ServiceResponse
   */
  header?: InlineResponse2002Header;
  /**
   *
   * @type {Array<InlineResponse2002Errors>}
   * @memberof ServiceResponse
   */
  errors?: Array<InlineResponse2002Errors>;
  /**
   *
   * @type {object}
   * @memberof ServiceResponse
   */
  payload?: object;
}

/**
 * @export
 * @enum {string}
 */
export enum ServiceResponseStatusEnum {
  Ok = "OK",
  Created = "CREATED",
  Accepted = "ACCEPTED",
  NoContent = "NO_CONTENT",
  Partial = "PARTIAL",
  MovedPermanent = "MOVED_PERMANENT",
  Found = "FOUND",
  SeeOther = "SEE_OTHER",
  NotModified = "NOT_MODIFIED",
  TemporaryRedirect = "TEMPORARY_REDIRECT",
  BadRequest = "BAD_REQUEST",
  Unauthorized = "UNAUTHORIZED",
  Forbidden = "FORBIDDEN",
  NotFound = "NOT_FOUND",
  MethodNotAllowed = "METHOD_NOT_ALLOWED",
  NotAcceptable = "NOT_ACCEPTABLE",
  RequestTimeout = "REQUEST_TIMEOUT",
  Conflict = "CONFLICT",
  RequestEntityTooLarge = "REQUEST_ENTITY_TOO_LARGE",
  UnsupportedMediaType = "UNSUPPORTED_MEDIA_TYPE",
  UnprocessableEntity = "UNPROCESSABLE_ENTITY",
  Fail = "FAIL",
  BadGateway = "BAD_GATEWAY",
  ServiceUnavailable = "SERVICE_UNAVAILABLE",
  GatewayTimeout = "GATEWAY_TIMEOUT",
}

/**
 * The address to which sellers need to inbound items
 * @export
 * @interface ShipToAddress
 */
export interface ShipToAddress {
  /**
   * Facility name
   * @type {string}
   * @memberof ShipToAddress
   */
  fcName?: string;
  /**
   * Address details
   * @type {string}
   * @memberof ShipToAddress
   */
  addressLine1?: string;
  /**
   * Address details continuation
   * @type {string}
   * @memberof ShipToAddress
   */
  addressLine2?: string;
  /**
   * City name
   * @type {string}
   * @memberof ShipToAddress
   */
  city?: string;
  /**
   * State code
   * @type {string}
   * @memberof ShipToAddress
   */
  stateCode?: string;
  /**
   * Country code
   * @type {string}
   * @memberof ShipToAddress
   */
  countryCode?: string;
  /**
   * Zip code
   * @type {string}
   * @memberof ShipToAddress
   */
  postalCode?: string;
}
/**
 * The items which needs to be send in the shipment
 * @export
 * @interface ShipmentItem
 */
export interface ShipmentItem {
  /**
   * Seller Item ID
   * @type {string}
   * @memberof ShipmentItem
   */
  vendorSku?: string;
  /**
   * Total number of sellable units
   * @type {number}
   * @memberof ShipmentItem
   */
  itemQty?: number;
}
/**
 * response payload
 * @export
 * @interface ShipmentItemDetails
 */
export interface ShipmentItemDetails {
  /**
   * Unique ID identifying inbound shipment request
   * @type {string}
   * @memberof ShipmentItemDetails
   */
  inboundOrderId?: string;
  /**
   * Unique ID identifying each shipment
   * @type {string}
   * @memberof ShipmentItemDetails
   */
  shipmentId?: string;
  /**
   * Item barcode
   * @type {string}
   * @memberof ShipmentItemDetails
   */
  gtin?: string;
  /**
   * Seller Item ID
   * @type {string}
   * @memberof ShipmentItemDetails
   */
  sku?: string;
  /**
   * Item description
   * @type {string}
   * @memberof ShipmentItemDetails
   */
  itemDesc?: string;
  /**
   * Total number of sellable units
   * @type {number}
   * @memberof ShipmentItemDetails
   */
  itemQty?: number;
  /**
   * Total number of cases
   * @type {number}
   * @memberof ShipmentItemDetails
   */
  vendorPackQty?: number;
  /**
   * Total number of sellable units per case
   * @type {number}
   * @memberof ShipmentItemDetails
   */
  innerPackQty?: number;
  /**
   * Qty received in FC
   * @type {number}
   * @memberof ShipmentItemDetails
   */
  receivedQty?: number;
  /**
   * Qty damaged while receiving in FC
   * @type {number}
   * @memberof ShipmentItemDetails
   */
  damagedQty?: number;
  /**
   * Fill rate for this shipment item
   * @type {number}
   * @memberof ShipmentItemDetails
   */
  fillRate?: number;
  /**
   * expected delivery date provided by seller
   * @type {string}
   * @memberof ShipmentItemDetails
   */
  expectedDeliveryDate?: string;
  /**
   * update expected delivery date based on network capacity
   * @type {string}
   * @memberof ShipmentItemDetails
   */
  updatedExpectedDeliveryDate?: string;
  /**
   * FC name
   * @type {string}
   * @memberof ShipmentItemDetails
   */
  shipNodeName?: string;
}
/**
 * response payload
 * @export
 * @interface ShipmentPlanDetails
 */
export interface ShipmentPlanDetails {
  /**
   * Unique ID identifying inbound shipment request
   * @type {string}
   * @memberof ShipmentPlanDetails
   */
  inboundOrderId?: string;
  /**
   * Unique ID identifying inbound shipment
   * @type {string}
   * @memberof ShipmentPlanDetails
   */
  shipmentId?: string;
  /**
   *
   * @type {InlineResponse200ShipToAddress}
   * @memberof ShipmentPlanDetails
   */
  shipToAddress?: InlineResponse200ShipToAddress;
  /**
   *
   * @type {InlineResponse200ReturnAddress}
   * @memberof ShipmentPlanDetails
   */
  returnAddress?: InlineResponse200ReturnAddress;
  /**
   * Current status of the shipment
   * @type {string}
   * @memberof ShipmentPlanDetails
   */
  status?: string;
  /**
   * creation date for shipment
   * @type {string}
   * @memberof ShipmentPlanDetails
   */
  createdDate?: string;
  /**
   * Total number of units in the shipment
   * @type {number}
   * @memberof ShipmentPlanDetails
   */
  shipmentUnits?: number;
  /**
   * Total number of units recived in FC for the shipment
   * @type {number}
   * @memberof ShipmentPlanDetails
   */
  receivedUnits?: number;
  /**
   * expected delivery date provided by seller
   * @type {string}
   * @memberof ShipmentPlanDetails
   */
  expectedDeliveryDate?: string;
  /**
   * update expected delivery date based on network capacity
   * @type {string}
   * @memberof ShipmentPlanDetails
   */
  updatedExpectedDeliveryDate?: string;
  /**
   * Actual delivery date of the shipment at FC
   * @type {string}
   * @memberof ShipmentPlanDetails
   */
  actualDeliveryDate?: string;
  /**
   * Tracking info for the shipment
   * @type {Array<string>}
   * @memberof ShipmentPlanDetails
   */
  trackingNo?: Array<string>;
  /**
   * Carrier of the shipment
   * @type {string}
   * @memberof ShipmentPlanDetails
   */
  carrierName?: string;
}
/**
 *
 * @export
 * @interface TrackingInfoWrapper
 */
export interface TrackingInfoWrapper {
  /**
   *
   * @type {string}
   * @memberof TrackingInfoWrapper
   */
  shipmentId: string;
  /**
   *
   * @type {string}
   * @memberof TrackingInfoWrapper
   */
  carrierName: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TrackingInfoWrapper
   */
  trackingInfo?: Array<string>;
}
/**
 * inbound shipment request line items
 * @export
 * @interface V3FulfillmentInboundShipmentsOrderItems
 */
export interface V3FulfillmentInboundShipmentsOrderItems {
  /**
   * Unique ID identifying product
   * @type {string}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  productId: string;
  /**
   * Supported product types are GTIN,UPC,EAN
   * @type {string}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  productType: string;
  /**
   * Seller Item ID
   * @type {string}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  sku: string;
  /**
   * Item description
   * @type {string}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  itemDesc: string;
  /**
   * Total number of sellable units
   * @type {number}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  itemQty: number;
  /**
   * Total number of cases
   * @type {number}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  vendorPackQty: number;
  /**
   * Total number of sellable units per case
   * @type {number}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  innerPackQty: number;
  /**
   * expected delivery date for shipment
   * @type {string}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  expectedDeliveryDate: string;
  /**
   *
   * @type {number}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  itemNbr?: number;
  /**
   *
   * @type {Array<number>}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  dimensions?: Array<number>;
  /**
   *
   * @type {number}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  itemWeightQty?: number;
  /**
   *
   * @type {boolean}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  nonSortItem?: boolean;
  /**
   *
   * @type {string}
   * @memberof V3FulfillmentInboundShipmentsOrderItems
   */
  shipNode?: string;
}
/**
 * update shipment qty line items
 * @export
 * @interface V3FulfillmentShipmentQuantitiesOrderItems
 */
export interface V3FulfillmentShipmentQuantitiesOrderItems {
  /**
   * Seller Item ID
   * @type {string}
   * @memberof V3FulfillmentShipmentQuantitiesOrderItems
   */
  sku: string;
  /**
   * updated quantity
   * @type {number}
   * @memberof V3FulfillmentShipmentQuantitiesOrderItems
   */
  updatedShipmentQty: number;
}

/**
 * FulfillmentApi - axios parameter creator
 * @export
 */
export const FulfillmentApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipment’s status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
     * @summary Cancel Inbound Shipment
     * @param {string} inboundOrderId Unique ID identifying inbound shipment request
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelShipment: async (
      inboundOrderId: string,
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      wMCONSUMERCHANNELTYPE?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'inboundOrderId' is not null or undefined
      assertParamExists("cancelShipment", "inboundOrderId", inboundOrderId);
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists("cancelShipment", "authorization", authorization);
      // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
      assertParamExists("cancelShipment", "wMSECACCESSTOKEN", wMSECACCESSTOKEN);
      // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
      assertParamExists(
        "cancelShipment",
        "wMQOSCORRELATIONID",
        wMQOSCORRELATIONID
      );
      // verify required parameter 'wMSVCNAME' is not null or undefined
      assertParamExists("cancelShipment", "wMSVCNAME", wMSVCNAME);
      const localVarPath =
        `/v3/fulfillment/inbound-shipments/{inboundOrderId}`.replace(
          `{${"inboundOrderId"}}`,
          encodeURIComponent(String(inboundOrderId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicScheme required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(authorization);
      }

      if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
        localVarHeaderParameter["WM_SEC.ACCESS_TOKEN"] =
          String(wMSECACCESSTOKEN);
      }

      if (
        wMCONSUMERCHANNELTYPE !== undefined &&
        wMCONSUMERCHANNELTYPE !== null
      ) {
        localVarHeaderParameter["WM_CONSUMER.CHANNEL.TYPE"] = String(
          wMCONSUMERCHANNELTYPE
        );
      }

      if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
        localVarHeaderParameter["WM_QOS.CORRELATION_ID"] =
          String(wMQOSCORRELATIONID);
      }

      if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
        localVarHeaderParameter["WM_SVC.NAME"] = String(wMSVCNAME);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This API is used for converting existing Marketplace items to be WFS eligible. Once you’ve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
     * @summary Convert items for WFS
     * @param {string} feedType Includes details of each entity in the feed. Do not set this parameter to true.
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    convertItemForWfs: async (
      feedType: string,
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      wMCONSUMERCHANNELTYPE?: string,
      file?: any,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'feedType' is not null or undefined
      assertParamExists("convertItemForWfs", "feedType", feedType);
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists("convertItemForWfs", "authorization", authorization);
      // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
      assertParamExists(
        "convertItemForWfs",
        "wMSECACCESSTOKEN",
        wMSECACCESSTOKEN
      );
      // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
      assertParamExists(
        "convertItemForWfs",
        "wMQOSCORRELATIONID",
        wMQOSCORRELATIONID
      );
      // verify required parameter 'wMSVCNAME' is not null or undefined
      assertParamExists("convertItemForWfs", "wMSVCNAME", wMSVCNAME);
      const localVarPath = `/v3/feeds`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication basicScheme required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (feedType !== undefined) {
        localVarQueryParameter["feedType"] = feedType;
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(authorization);
      }

      if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
        localVarHeaderParameter["WM_SEC.ACCESS_TOKEN"] =
          String(wMSECACCESSTOKEN);
      }

      if (
        wMCONSUMERCHANNELTYPE !== undefined &&
        wMCONSUMERCHANNELTYPE !== null
      ) {
        localVarHeaderParameter["WM_CONSUMER.CHANNEL.TYPE"] = String(
          wMCONSUMERCHANNELTYPE
        );
      }

      if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
        localVarHeaderParameter["WM_QOS.CORRELATION_ID"] =
          String(wMQOSCORRELATIONID);
      }

      if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
        localVarHeaderParameter["WM_SVC.NAME"] = String(wMSVCNAME);
      }

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets.
     * @summary Create Inbound Shipment label
     * @param {string} shipmentId Unique ID identifying inbound shipment
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInboundShipmentLabel: async (
      shipmentId: string,
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      wMCONSUMERCHANNELTYPE?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'shipmentId' is not null or undefined
      assertParamExists("createInboundShipmentLabel", "shipmentId", shipmentId);
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists(
        "createInboundShipmentLabel",
        "authorization",
        authorization
      );
      // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
      assertParamExists(
        "createInboundShipmentLabel",
        "wMSECACCESSTOKEN",
        wMSECACCESSTOKEN
      );
      // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
      assertParamExists(
        "createInboundShipmentLabel",
        "wMQOSCORRELATIONID",
        wMQOSCORRELATIONID
      );
      // verify required parameter 'wMSVCNAME' is not null or undefined
      assertParamExists("createInboundShipmentLabel", "wMSVCNAME", wMSVCNAME);
      const localVarPath = `/v3/fulfillment/label/{shipmentId}`.replace(
        `{${"shipmentId"}}`,
        encodeURIComponent(String(shipmentId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicScheme required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(authorization);
      }

      if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
        localVarHeaderParameter["WM_SEC.ACCESS_TOKEN"] =
          String(wMSECACCESSTOKEN);
      }

      if (
        wMCONSUMERCHANNELTYPE !== undefined &&
        wMCONSUMERCHANNELTYPE !== null
      ) {
        localVarHeaderParameter["WM_CONSUMER.CHANNEL.TYPE"] = String(
          wMCONSUMERCHANNELTYPE
        );
      }

      if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
        localVarHeaderParameter["WM_QOS.CORRELATION_ID"] =
          String(wMQOSCORRELATIONID);
      }

      if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
        localVarHeaderParameter["WM_SVC.NAME"] = String(wMSVCNAME);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Once you’ve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment. In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
     * @summary Create Inbound Shipment
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {InlineObject} inlineObject
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShipment: async (
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      inlineObject: InlineObject,
      wMCONSUMERCHANNELTYPE?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists("createShipment", "authorization", authorization);
      // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
      assertParamExists("createShipment", "wMSECACCESSTOKEN", wMSECACCESSTOKEN);
      // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
      assertParamExists(
        "createShipment",
        "wMQOSCORRELATIONID",
        wMQOSCORRELATIONID
      );
      // verify required parameter 'wMSVCNAME' is not null or undefined
      assertParamExists("createShipment", "wMSVCNAME", wMSVCNAME);
      // verify required parameter 'inlineObject' is not null or undefined
      assertParamExists("createShipment", "inlineObject", inlineObject);
      const localVarPath = `/v3/fulfillment/inbound-shipments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicScheme required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(authorization);
      }

      if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
        localVarHeaderParameter["WM_SEC.ACCESS_TOKEN"] =
          String(wMSECACCESSTOKEN);
      }

      if (
        wMCONSUMERCHANNELTYPE !== undefined &&
        wMCONSUMERCHANNELTYPE !== null
      ) {
        localVarHeaderParameter["WM_CONSUMER.CHANNEL.TYPE"] = String(
          wMCONSUMERCHANNELTYPE
        );
      }

      if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
        localVarHeaderParameter["WM_QOS.CORRELATION_ID"] =
          String(wMQOSCORRELATIONID);
      }

      if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
        localVarHeaderParameter["WM_SVC.NAME"] = String(wMSVCNAME);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible.
     * @summary Get Inbound Shipment errors
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
     * @param {string} [limit] The number of Purchase Orders to be returned.
     * @param {string} [shipmentId] Unique ID identifying each shipment.
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboundOrderErrors: async (
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      offset?: string,
      limit?: string,
      shipmentId?: string,
      wMCONSUMERCHANNELTYPE?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists(
        "getInboundOrderErrors",
        "authorization",
        authorization
      );
      // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
      assertParamExists(
        "getInboundOrderErrors",
        "wMSECACCESSTOKEN",
        wMSECACCESSTOKEN
      );
      // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
      assertParamExists(
        "getInboundOrderErrors",
        "wMQOSCORRELATIONID",
        wMQOSCORRELATIONID
      );
      // verify required parameter 'wMSVCNAME' is not null or undefined
      assertParamExists("getInboundOrderErrors", "wMSVCNAME", wMSVCNAME);
      const localVarPath = `/v3/fulfillment/inbound-shipment-errors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicScheme required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (shipmentId !== undefined) {
        localVarQueryParameter["shipmentId"] = shipmentId;
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(authorization);
      }

      if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
        localVarHeaderParameter["WM_SEC.ACCESS_TOKEN"] =
          String(wMSECACCESSTOKEN);
      }

      if (
        wMCONSUMERCHANNELTYPE !== undefined &&
        wMCONSUMERCHANNELTYPE !== null
      ) {
        localVarHeaderParameter["WM_CONSUMER.CHANNEL.TYPE"] = String(
          wMCONSUMERCHANNELTYPE
        );
      }

      if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
        localVarHeaderParameter["WM_QOS.CORRELATION_ID"] =
          String(wMQOSCORRELATIONID);
      }

      if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
        localVarHeaderParameter["WM_SVC.NAME"] = String(wMSVCNAME);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
     * @summary Get Inbound Shipment Items
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
     * @param {string} [limit] The number of Purchase Orders to be returned.
     * @param {string} [shipmentId] Unique ID identifying each shipment.
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboundShipmentItems: async (
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      offset?: string,
      limit?: string,
      shipmentId?: string,
      wMCONSUMERCHANNELTYPE?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists(
        "getInboundShipmentItems",
        "authorization",
        authorization
      );
      // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
      assertParamExists(
        "getInboundShipmentItems",
        "wMSECACCESSTOKEN",
        wMSECACCESSTOKEN
      );
      // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
      assertParamExists(
        "getInboundShipmentItems",
        "wMQOSCORRELATIONID",
        wMQOSCORRELATIONID
      );
      // verify required parameter 'wMSVCNAME' is not null or undefined
      assertParamExists("getInboundShipmentItems", "wMSVCNAME", wMSVCNAME);
      const localVarPath = `/v3/fulfillment/inbound-shipment-items`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicScheme required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (shipmentId !== undefined) {
        localVarQueryParameter["shipmentId"] = shipmentId;
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(authorization);
      }

      if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
        localVarHeaderParameter["WM_SEC.ACCESS_TOKEN"] =
          String(wMSECACCESSTOKEN);
      }

      if (
        wMCONSUMERCHANNELTYPE !== undefined &&
        wMCONSUMERCHANNELTYPE !== null
      ) {
        localVarHeaderParameter["WM_CONSUMER.CHANNEL.TYPE"] = String(
          wMCONSUMERCHANNELTYPE
        );
      }

      if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
        localVarHeaderParameter["WM_QOS.CORRELATION_ID"] =
          String(wMQOSCORRELATIONID);
      }

      if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
        localVarHeaderParameter["WM_SVC.NAME"] = String(wMSVCNAME);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
     * @summary Get Shipments
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
     * @param {string} [limit] The number of Purchase Orders to be returned.
     * @param {string} [inboundOrderId] Unique ID identifying inbound shipment request.
     * @param {string} [shipmentId] Unique ID identifying each shipment.
     * @param {string} [status] Current shipment status
     * @param {string} [fromCreateDate] Shipment create date starting range
     * @param {string} [toCreateDate] Shipment create date starting  end range
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboundShipments: async (
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      offset?: string,
      limit?: string,
      inboundOrderId?: string,
      shipmentId?: string,
      status?: string,
      fromCreateDate?: string,
      toCreateDate?: string,
      wMCONSUMERCHANNELTYPE?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists("getInboundShipments", "authorization", authorization);
      // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
      assertParamExists(
        "getInboundShipments",
        "wMSECACCESSTOKEN",
        wMSECACCESSTOKEN
      );
      // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
      assertParamExists(
        "getInboundShipments",
        "wMQOSCORRELATIONID",
        wMQOSCORRELATIONID
      );
      // verify required parameter 'wMSVCNAME' is not null or undefined
      assertParamExists("getInboundShipments", "wMSVCNAME", wMSVCNAME);
      const localVarPath = `/v3/fulfillment/inbound-shipments`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicScheme required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (inboundOrderId !== undefined) {
        localVarQueryParameter["inboundOrderId"] = inboundOrderId;
      }

      if (shipmentId !== undefined) {
        localVarQueryParameter["shipmentId"] = shipmentId;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (fromCreateDate !== undefined) {
        localVarQueryParameter["fromCreateDate"] = fromCreateDate;
      }

      if (toCreateDate !== undefined) {
        localVarQueryParameter["toCreateDate"] = toCreateDate;
      }

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(authorization);
      }

      if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
        localVarHeaderParameter["WM_SEC.ACCESS_TOKEN"] =
          String(wMSECACCESSTOKEN);
      }

      if (
        wMCONSUMERCHANNELTYPE !== undefined &&
        wMCONSUMERCHANNELTYPE !== null
      ) {
        localVarHeaderParameter["WM_CONSUMER.CHANNEL.TYPE"] = String(
          wMCONSUMERCHANNELTYPE
        );
      }

      if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
        localVarHeaderParameter["WM_QOS.CORRELATION_ID"] =
          String(wMQOSCORRELATIONID);
      }

      if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
        localVarHeaderParameter["WM_SVC.NAME"] = String(wMSVCNAME);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs’ quantity to 0 – they must cancel the entire Inbound Order.
     * @summary Update Shipment Quantities
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {InlineObject3} inlineObject3
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShipmentQuantity: async (
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      inlineObject3: InlineObject3,
      wMCONSUMERCHANNELTYPE?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists(
        "updateShipmentQuantity",
        "authorization",
        authorization
      );
      // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
      assertParamExists(
        "updateShipmentQuantity",
        "wMSECACCESSTOKEN",
        wMSECACCESSTOKEN
      );
      // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
      assertParamExists(
        "updateShipmentQuantity",
        "wMQOSCORRELATIONID",
        wMQOSCORRELATIONID
      );
      // verify required parameter 'wMSVCNAME' is not null or undefined
      assertParamExists("updateShipmentQuantity", "wMSVCNAME", wMSVCNAME);
      // verify required parameter 'inlineObject3' is not null or undefined
      assertParamExists(
        "updateShipmentQuantity",
        "inlineObject3",
        inlineObject3
      );
      const localVarPath = `/v3/fulfillment/shipment-quantities`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicScheme required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(authorization);
      }

      if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
        localVarHeaderParameter["WM_SEC.ACCESS_TOKEN"] =
          String(wMSECACCESSTOKEN);
      }

      if (
        wMCONSUMERCHANNELTYPE !== undefined &&
        wMCONSUMERCHANNELTYPE !== null
      ) {
        localVarHeaderParameter["WM_CONSUMER.CHANNEL.TYPE"] = String(
          wMCONSUMERCHANNELTYPE
        );
      }

      if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
        localVarHeaderParameter["WM_QOS.CORRELATION_ID"] =
          String(wMQOSCORRELATIONID);
      }

      if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
        localVarHeaderParameter["WM_SVC.NAME"] = String(wMSVCNAME);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject3,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
     * @summary Update Shipment Tracking
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {InlineObject1} inlineObject1
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShipmentTrackingDetails: async (
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      inlineObject1: InlineObject1,
      wMCONSUMERCHANNELTYPE?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists(
        "updateShipmentTrackingDetails",
        "authorization",
        authorization
      );
      // verify required parameter 'wMSECACCESSTOKEN' is not null or undefined
      assertParamExists(
        "updateShipmentTrackingDetails",
        "wMSECACCESSTOKEN",
        wMSECACCESSTOKEN
      );
      // verify required parameter 'wMQOSCORRELATIONID' is not null or undefined
      assertParamExists(
        "updateShipmentTrackingDetails",
        "wMQOSCORRELATIONID",
        wMQOSCORRELATIONID
      );
      // verify required parameter 'wMSVCNAME' is not null or undefined
      assertParamExists(
        "updateShipmentTrackingDetails",
        "wMSVCNAME",
        wMSVCNAME
      );
      // verify required parameter 'inlineObject1' is not null or undefined
      assertParamExists(
        "updateShipmentTrackingDetails",
        "inlineObject1",
        inlineObject1
      );
      const localVarPath = `/v3/fulfillment/shipment-tracking`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication basicScheme required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration);

      if (authorization !== undefined && authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(authorization);
      }

      if (wMSECACCESSTOKEN !== undefined && wMSECACCESSTOKEN !== null) {
        localVarHeaderParameter["WM_SEC.ACCESS_TOKEN"] =
          String(wMSECACCESSTOKEN);
      }

      if (
        wMCONSUMERCHANNELTYPE !== undefined &&
        wMCONSUMERCHANNELTYPE !== null
      ) {
        localVarHeaderParameter["WM_CONSUMER.CHANNEL.TYPE"] = String(
          wMCONSUMERCHANNELTYPE
        );
      }

      if (wMQOSCORRELATIONID !== undefined && wMQOSCORRELATIONID !== null) {
        localVarHeaderParameter["WM_QOS.CORRELATION_ID"] =
          String(wMQOSCORRELATIONID);
      }

      if (wMSVCNAME !== undefined && wMSVCNAME !== null) {
        localVarHeaderParameter["WM_SVC.NAME"] = String(wMSVCNAME);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject1,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FulfillmentApi - functional programming interface
 * @export
 */
export const FulfillmentApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    FulfillmentApiAxiosParamCreator(configuration);
  return {
    /**
     * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipment’s status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
     * @summary Cancel Inbound Shipment
     * @param {string} inboundOrderId Unique ID identifying inbound shipment request
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelShipment(
      inboundOrderId: string,
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2002>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelShipment(
        inboundOrderId,
        authorization,
        wMSECACCESSTOKEN,
        wMQOSCORRELATIONID,
        wMSVCNAME,
        wMCONSUMERCHANNELTYPE,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * This API is used for converting existing Marketplace items to be WFS eligible. Once you’ve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
     * @summary Convert items for WFS
     * @param {string} feedType Includes details of each entity in the feed. Do not set this parameter to true.
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async convertItemForWfs(
      feedType: string,
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      wMCONSUMERCHANNELTYPE?: string,
      file?: any,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2003>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.convertItemForWfs(
          feedType,
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          wMCONSUMERCHANNELTYPE,
          file,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets.
     * @summary Create Inbound Shipment label
     * @param {string} shipmentId Unique ID identifying inbound shipment
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createInboundShipmentLabel(
      shipmentId: string,
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createInboundShipmentLabel(
          shipmentId,
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          wMCONSUMERCHANNELTYPE,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Once you’ve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment. In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
     * @summary Create Inbound Shipment
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {InlineObject} inlineObject
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createShipment(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      inlineObject: InlineObject,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2001>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createShipment(
        authorization,
        wMSECACCESSTOKEN,
        wMQOSCORRELATIONID,
        wMSVCNAME,
        inlineObject,
        wMCONSUMERCHANNELTYPE,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible.
     * @summary Get Inbound Shipment errors
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
     * @param {string} [limit] The number of Purchase Orders to be returned.
     * @param {string} [shipmentId] Unique ID identifying each shipment.
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInboundOrderErrors(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      offset?: string,
      limit?: string,
      shipmentId?: string,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2004>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getInboundOrderErrors(
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          offset,
          limit,
          shipmentId,
          wMCONSUMERCHANNELTYPE,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
     * @summary Get Inbound Shipment Items
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
     * @param {string} [limit] The number of Purchase Orders to be returned.
     * @param {string} [shipmentId] Unique ID identifying each shipment.
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInboundShipmentItems(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      offset?: string,
      limit?: string,
      shipmentId?: string,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2005>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getInboundShipmentItems(
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          offset,
          limit,
          shipmentId,
          wMCONSUMERCHANNELTYPE,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
     * @summary Get Shipments
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
     * @param {string} [limit] The number of Purchase Orders to be returned.
     * @param {string} [inboundOrderId] Unique ID identifying inbound shipment request.
     * @param {string} [shipmentId] Unique ID identifying each shipment.
     * @param {string} [status] Current shipment status
     * @param {string} [fromCreateDate] Shipment create date starting range
     * @param {string} [toCreateDate] Shipment create date starting  end range
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInboundShipments(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      offset?: string,
      limit?: string,
      inboundOrderId?: string,
      shipmentId?: string,
      status?: string,
      fromCreateDate?: string,
      toCreateDate?: string,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getInboundShipments(
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          offset,
          limit,
          inboundOrderId,
          shipmentId,
          status,
          fromCreateDate,
          toCreateDate,
          wMCONSUMERCHANNELTYPE,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs’ quantity to 0 – they must cancel the entire Inbound Order.
     * @summary Update Shipment Quantities
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {InlineObject3} inlineObject3
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateShipmentQuantity(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      inlineObject3: InlineObject3,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2002>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateShipmentQuantity(
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          inlineObject3,
          wMCONSUMERCHANNELTYPE,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
     * @summary Update Shipment Tracking
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {InlineObject1} inlineObject1
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateShipmentTrackingDetails(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      inlineObject1: InlineObject1,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2002>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateShipmentTrackingDetails(
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          inlineObject1,
          wMCONSUMERCHANNELTYPE,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * FulfillmentApi - factory interface
 * @export
 */
export const FulfillmentApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FulfillmentApiFp(configuration);
  return {
    /**
     * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipment’s status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
     * @summary Cancel Inbound Shipment
     * @param {string} inboundOrderId Unique ID identifying inbound shipment request
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelShipment(
      inboundOrderId: string,
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): AxiosPromise<InlineResponse2002> {
      return localVarFp
        .cancelShipment(
          inboundOrderId,
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          wMCONSUMERCHANNELTYPE,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * This API is used for converting existing Marketplace items to be WFS eligible. Once you’ve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
     * @summary Convert items for WFS
     * @param {string} feedType Includes details of each entity in the feed. Do not set this parameter to true.
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {any} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    convertItemForWfs(
      feedType: string,
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      wMCONSUMERCHANNELTYPE?: string,
      file?: any,
      options?: any
    ): AxiosPromise<InlineResponse2003> {
      return localVarFp
        .convertItemForWfs(
          feedType,
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          wMCONSUMERCHANNELTYPE,
          file,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets.
     * @summary Create Inbound Shipment label
     * @param {string} shipmentId Unique ID identifying inbound shipment
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInboundShipmentLabel(
      shipmentId: string,
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): AxiosPromise<string> {
      return localVarFp
        .createInboundShipmentLabel(
          shipmentId,
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          wMCONSUMERCHANNELTYPE,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Once you’ve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment. In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
     * @summary Create Inbound Shipment
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {InlineObject} inlineObject
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShipment(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      inlineObject: InlineObject,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): AxiosPromise<InlineResponse2001> {
      return localVarFp
        .createShipment(
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          inlineObject,
          wMCONSUMERCHANNELTYPE,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible.
     * @summary Get Inbound Shipment errors
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
     * @param {string} [limit] The number of Purchase Orders to be returned.
     * @param {string} [shipmentId] Unique ID identifying each shipment.
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboundOrderErrors(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      offset?: string,
      limit?: string,
      shipmentId?: string,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): AxiosPromise<InlineResponse2004> {
      return localVarFp
        .getInboundOrderErrors(
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          offset,
          limit,
          shipmentId,
          wMCONSUMERCHANNELTYPE,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
     * @summary Get Inbound Shipment Items
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
     * @param {string} [limit] The number of Purchase Orders to be returned.
     * @param {string} [shipmentId] Unique ID identifying each shipment.
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboundShipmentItems(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      offset?: string,
      limit?: string,
      shipmentId?: string,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): AxiosPromise<InlineResponse2005> {
      return localVarFp
        .getInboundShipmentItems(
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          offset,
          limit,
          shipmentId,
          wMCONSUMERCHANNELTYPE,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
     * @summary Get Shipments
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {string} [offset] offset is the number of records you wish to skip before selecting records.
     * @param {string} [limit] The number of Purchase Orders to be returned.
     * @param {string} [inboundOrderId] Unique ID identifying inbound shipment request.
     * @param {string} [shipmentId] Unique ID identifying each shipment.
     * @param {string} [status] Current shipment status
     * @param {string} [fromCreateDate] Shipment create date starting range
     * @param {string} [toCreateDate] Shipment create date starting  end range
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInboundShipments(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      offset?: string,
      limit?: string,
      inboundOrderId?: string,
      shipmentId?: string,
      status?: string,
      fromCreateDate?: string,
      toCreateDate?: string,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): AxiosPromise<InlineResponse200> {
      return localVarFp
        .getInboundShipments(
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          offset,
          limit,
          inboundOrderId,
          shipmentId,
          status,
          fromCreateDate,
          toCreateDate,
          wMCONSUMERCHANNELTYPE,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs’ quantity to 0 – they must cancel the entire Inbound Order.
     * @summary Update Shipment Quantities
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {InlineObject3} inlineObject3
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShipmentQuantity(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      inlineObject3: InlineObject3,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): AxiosPromise<InlineResponse2002> {
      return localVarFp
        .updateShipmentQuantity(
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          inlineObject3,
          wMCONSUMERCHANNELTYPE,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
     * @summary Update Shipment Tracking
     * @param {string} authorization Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
     * @param {string} wMSECACCESSTOKEN The access token retrieved in the Token API call
     * @param {string} wMQOSCORRELATIONID A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
     * @param {string} wMSVCNAME Walmart Service Name
     * @param {InlineObject1} inlineObject1
     * @param {string} [wMCONSUMERCHANNELTYPE] A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShipmentTrackingDetails(
      authorization: string,
      wMSECACCESSTOKEN: string,
      wMQOSCORRELATIONID: string,
      wMSVCNAME: string,
      inlineObject1: InlineObject1,
      wMCONSUMERCHANNELTYPE?: string,
      options?: any
    ): AxiosPromise<InlineResponse2002> {
      return localVarFp
        .updateShipmentTrackingDetails(
          authorization,
          wMSECACCESSTOKEN,
          wMQOSCORRELATIONID,
          wMSVCNAME,
          inlineObject1,
          wMCONSUMERCHANNELTYPE,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for cancelShipment operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCancelShipmentRequest
 */
export interface FulfillmentApiCancelShipmentRequest {
  /**
   * Unique ID identifying inbound shipment request
   * @type {string}
   * @memberof FulfillmentApiCancelShipment
   */
  readonly inboundOrderId: string;

  /**
   * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
   * @type {string}
   * @memberof FulfillmentApiCancelShipment
   */
  readonly authorization: string;

  /**
   * The access token retrieved in the Token API call
   * @type {string}
   * @memberof FulfillmentApiCancelShipment
   */
  readonly wMSECACCESSTOKEN: string;

  /**
   * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
   * @type {string}
   * @memberof FulfillmentApiCancelShipment
   */
  readonly wMQOSCORRELATIONID: string;

  /**
   * Walmart Service Name
   * @type {string}
   * @memberof FulfillmentApiCancelShipment
   */
  readonly wMSVCNAME: string;

  /**
   * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
   * @type {string}
   * @memberof FulfillmentApiCancelShipment
   */
  readonly wMCONSUMERCHANNELTYPE?: string;
}

/**
 * Request parameters for convertItemForWfs operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiConvertItemForWfsRequest
 */
export interface FulfillmentApiConvertItemForWfsRequest {
  /**
   * Includes details of each entity in the feed. Do not set this parameter to true.
   * @type {string}
   * @memberof FulfillmentApiConvertItemForWfs
   */
  readonly feedType: string;

  /**
   * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
   * @type {string}
   * @memberof FulfillmentApiConvertItemForWfs
   */
  readonly authorization: string;

  /**
   * The access token retrieved in the Token API call
   * @type {string}
   * @memberof FulfillmentApiConvertItemForWfs
   */
  readonly wMSECACCESSTOKEN: string;

  /**
   * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
   * @type {string}
   * @memberof FulfillmentApiConvertItemForWfs
   */
  readonly wMQOSCORRELATIONID: string;

  /**
   * Walmart Service Name
   * @type {string}
   * @memberof FulfillmentApiConvertItemForWfs
   */
  readonly wMSVCNAME: string;

  /**
   * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
   * @type {string}
   * @memberof FulfillmentApiConvertItemForWfs
   */
  readonly wMCONSUMERCHANNELTYPE?: string;

  /**
   *
   * @type {any}
   * @memberof FulfillmentApiConvertItemForWfs
   */
  readonly file?: any;
}

/**
 * Request parameters for createInboundShipmentLabel operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCreateInboundShipmentLabelRequest
 */
export interface FulfillmentApiCreateInboundShipmentLabelRequest {
  /**
   * Unique ID identifying inbound shipment
   * @type {string}
   * @memberof FulfillmentApiCreateInboundShipmentLabel
   */
  readonly shipmentId: string;

  /**
   * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
   * @type {string}
   * @memberof FulfillmentApiCreateInboundShipmentLabel
   */
  readonly authorization: string;

  /**
   * The access token retrieved in the Token API call
   * @type {string}
   * @memberof FulfillmentApiCreateInboundShipmentLabel
   */
  readonly wMSECACCESSTOKEN: string;

  /**
   * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
   * @type {string}
   * @memberof FulfillmentApiCreateInboundShipmentLabel
   */
  readonly wMQOSCORRELATIONID: string;

  /**
   * Walmart Service Name
   * @type {string}
   * @memberof FulfillmentApiCreateInboundShipmentLabel
   */
  readonly wMSVCNAME: string;

  /**
   * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
   * @type {string}
   * @memberof FulfillmentApiCreateInboundShipmentLabel
   */
  readonly wMCONSUMERCHANNELTYPE?: string;
}

/**
 * Request parameters for createShipment operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiCreateShipmentRequest
 */
export interface FulfillmentApiCreateShipmentRequest {
  /**
   * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
   * @type {string}
   * @memberof FulfillmentApiCreateShipment
   */
  readonly authorization: string;

  /**
   * The access token retrieved in the Token API call
   * @type {string}
   * @memberof FulfillmentApiCreateShipment
   */
  readonly wMSECACCESSTOKEN: string;

  /**
   * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
   * @type {string}
   * @memberof FulfillmentApiCreateShipment
   */
  readonly wMQOSCORRELATIONID: string;

  /**
   * Walmart Service Name
   * @type {string}
   * @memberof FulfillmentApiCreateShipment
   */
  readonly wMSVCNAME: string;

  /**
   *
   * @type {InlineObject}
   * @memberof FulfillmentApiCreateShipment
   */
  readonly inlineObject: InlineObject;

  /**
   * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
   * @type {string}
   * @memberof FulfillmentApiCreateShipment
   */
  readonly wMCONSUMERCHANNELTYPE?: string;
}

/**
 * Request parameters for getInboundOrderErrors operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetInboundOrderErrorsRequest
 */
export interface FulfillmentApiGetInboundOrderErrorsRequest {
  /**
   * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
   * @type {string}
   * @memberof FulfillmentApiGetInboundOrderErrors
   */
  readonly authorization: string;

  /**
   * The access token retrieved in the Token API call
   * @type {string}
   * @memberof FulfillmentApiGetInboundOrderErrors
   */
  readonly wMSECACCESSTOKEN: string;

  /**
   * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
   * @type {string}
   * @memberof FulfillmentApiGetInboundOrderErrors
   */
  readonly wMQOSCORRELATIONID: string;

  /**
   * Walmart Service Name
   * @type {string}
   * @memberof FulfillmentApiGetInboundOrderErrors
   */
  readonly wMSVCNAME: string;

  /**
   * offset is the number of records you wish to skip before selecting records.
   * @type {string}
   * @memberof FulfillmentApiGetInboundOrderErrors
   */
  readonly offset?: string;

  /**
   * The number of Purchase Orders to be returned.
   * @type {string}
   * @memberof FulfillmentApiGetInboundOrderErrors
   */
  readonly limit?: string;

  /**
   * Unique ID identifying each shipment.
   * @type {string}
   * @memberof FulfillmentApiGetInboundOrderErrors
   */
  readonly shipmentId?: string;

  /**
   * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
   * @type {string}
   * @memberof FulfillmentApiGetInboundOrderErrors
   */
  readonly wMCONSUMERCHANNELTYPE?: string;
}

/**
 * Request parameters for getInboundShipmentItems operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetInboundShipmentItemsRequest
 */
export interface FulfillmentApiGetInboundShipmentItemsRequest {
  /**
   * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipmentItems
   */
  readonly authorization: string;

  /**
   * The access token retrieved in the Token API call
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipmentItems
   */
  readonly wMSECACCESSTOKEN: string;

  /**
   * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipmentItems
   */
  readonly wMQOSCORRELATIONID: string;

  /**
   * Walmart Service Name
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipmentItems
   */
  readonly wMSVCNAME: string;

  /**
   * offset is the number of records you wish to skip before selecting records.
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipmentItems
   */
  readonly offset?: string;

  /**
   * The number of Purchase Orders to be returned.
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipmentItems
   */
  readonly limit?: string;

  /**
   * Unique ID identifying each shipment.
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipmentItems
   */
  readonly shipmentId?: string;

  /**
   * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipmentItems
   */
  readonly wMCONSUMERCHANNELTYPE?: string;
}

/**
 * Request parameters for getInboundShipments operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiGetInboundShipmentsRequest
 */
export interface FulfillmentApiGetInboundShipmentsRequest {
  /**
   * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly authorization: string;

  /**
   * The access token retrieved in the Token API call
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly wMSECACCESSTOKEN: string;

  /**
   * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly wMQOSCORRELATIONID: string;

  /**
   * Walmart Service Name
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly wMSVCNAME: string;

  /**
   * offset is the number of records you wish to skip before selecting records.
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly offset?: string;

  /**
   * The number of Purchase Orders to be returned.
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly limit?: string;

  /**
   * Unique ID identifying inbound shipment request.
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly inboundOrderId?: string;

  /**
   * Unique ID identifying each shipment.
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly shipmentId?: string;

  /**
   * Current shipment status
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly status?: string;

  /**
   * Shipment create date starting range
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly fromCreateDate?: string;

  /**
   * Shipment create date starting  end range
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly toCreateDate?: string;

  /**
   * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
   * @type {string}
   * @memberof FulfillmentApiGetInboundShipments
   */
  readonly wMCONSUMERCHANNELTYPE?: string;
}

/**
 * Request parameters for updateShipmentQuantity operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiUpdateShipmentQuantityRequest
 */
export interface FulfillmentApiUpdateShipmentQuantityRequest {
  /**
   * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
   * @type {string}
   * @memberof FulfillmentApiUpdateShipmentQuantity
   */
  readonly authorization: string;

  /**
   * The access token retrieved in the Token API call
   * @type {string}
   * @memberof FulfillmentApiUpdateShipmentQuantity
   */
  readonly wMSECACCESSTOKEN: string;

  /**
   * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
   * @type {string}
   * @memberof FulfillmentApiUpdateShipmentQuantity
   */
  readonly wMQOSCORRELATIONID: string;

  /**
   * Walmart Service Name
   * @type {string}
   * @memberof FulfillmentApiUpdateShipmentQuantity
   */
  readonly wMSVCNAME: string;

  /**
   *
   * @type {InlineObject3}
   * @memberof FulfillmentApiUpdateShipmentQuantity
   */
  readonly inlineObject3: InlineObject3;

  /**
   * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
   * @type {string}
   * @memberof FulfillmentApiUpdateShipmentQuantity
   */
  readonly wMCONSUMERCHANNELTYPE?: string;
}

/**
 * Request parameters for updateShipmentTrackingDetails operation in FulfillmentApi.
 * @export
 * @interface FulfillmentApiUpdateShipmentTrackingDetailsRequest
 */
export interface FulfillmentApiUpdateShipmentTrackingDetailsRequest {
  /**
   * Basic authorization header. Base 64 encodes the Client ID and Client Secret retrieved in step two of the integration steps.
   * @type {string}
   * @memberof FulfillmentApiUpdateShipmentTrackingDetails
   */
  readonly authorization: string;

  /**
   * The access token retrieved in the Token API call
   * @type {string}
   * @memberof FulfillmentApiUpdateShipmentTrackingDetails
   */
  readonly wMSECACCESSTOKEN: string;

  /**
   * A unique ID which identifies each API call and used to track and debug issues; use a random generated GUID for this ID
   * @type {string}
   * @memberof FulfillmentApiUpdateShipmentTrackingDetails
   */
  readonly wMQOSCORRELATIONID: string;

  /**
   * Walmart Service Name
   * @type {string}
   * @memberof FulfillmentApiUpdateShipmentTrackingDetails
   */
  readonly wMSVCNAME: string;

  /**
   *
   * @type {InlineObject1}
   * @memberof FulfillmentApiUpdateShipmentTrackingDetails
   */
  readonly inlineObject1: InlineObject1;

  /**
   * A unique ID to track the consumer request by channel. Use the Consumer Channel Type received during onboarding
   * @type {string}
   * @memberof FulfillmentApiUpdateShipmentTrackingDetails
   */
  readonly wMCONSUMERCHANNELTYPE?: string;
}

/**
 * FulfillmentApi - object-oriented interface
 * @export
 * @class FulfillmentApi
 * @extends {BaseAPI}
 */
export class FulfillmentApi extends BaseAPI {
  /**
   * The purpose of this service is to cancel an inbound order. Seller can cancel an Inbound Order before any of its Shipment arrives at the WFS FCs. Seller cannot cancel an Inbound Order if any of its Shipment’s status = Receiving in Progress, Closed, or Cancelled  Seller can only cancel at the Inbound Order level, not the Shipment level: if an Inbound Order is cancelled, all Shipments on that order will be cancelled.
   * @summary Cancel Inbound Shipment
   * @param {FulfillmentApiCancelShipmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FulfillmentApi
   */
  public cancelShipment(
    requestParameters: FulfillmentApiCancelShipmentRequest,
    options?: any
  ) {
    return FulfillmentApiFp(this.configuration)
      .cancelShipment(
        requestParameters.inboundOrderId,
        requestParameters.authorization,
        requestParameters.wMSECACCESSTOKEN,
        requestParameters.wMQOSCORRELATIONID,
        requestParameters.wMSVCNAME,
        requestParameters.wMCONSUMERCHANNELTYPE,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This API is used for converting existing Marketplace items to be WFS eligible. Once you’ve created a Marketplace item, each item must be converted to WFS by providing additional details that are not required during the item setup process. This item conversion process can be completed by uploading the Convert Spec excel file via Seller Center, or can be completed using the API documented here.  Directions on how to convert your item to be eligible for Walmart Fulfillment Services can be found here: https://sellerhelp.walmart.com/s/guide?article=000009206  Additional details on hazmat item compliance requirements can be found here: https://sellerhelp.walmart.com/seller/s/guide?article=000009156  To download the schema, please refer to the Overview section
   * @summary Convert items for WFS
   * @param {FulfillmentApiConvertItemForWfsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FulfillmentApi
   */
  public convertItemForWfs(
    requestParameters: FulfillmentApiConvertItemForWfsRequest,
    options?: any
  ) {
    return FulfillmentApiFp(this.configuration)
      .convertItemForWfs(
        requestParameters.feedType,
        requestParameters.authorization,
        requestParameters.wMSECACCESSTOKEN,
        requestParameters.wMQOSCORRELATIONID,
        requestParameters.wMSVCNAME,
        requestParameters.wMCONSUMERCHANNELTYPE,
        requestParameters.file,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The purpose of this service is to generate WFS shipping labels in pdf format for receiving purpose. Please note this is not a carrier label; these labels are required for the FC to identify the Inbound Order and Shipment ID they are receiving against. After requesting the shipping label, sellers must work with warehouse/ supplier to follow these steps before sending any Shipments to WFS FCs:  1.  Print the WFS shipping label. 2.  Fill out the FILL OUT section based on seller’s packing situation. For example, if a seller plans to ship 3 boxes to the WFS fulfillment center, print out 3 labels and fill out BOX 1 of 3, 2 of 3, and 3 of 3 in the FILL OUT section. 3.  Circle one shipment type in the CIRCLE ONE section. For example, if there are different SKUs in the box, circle MIXED SKUS in the CIRCLE ONE section. 4.  Affix the WFS shipping labels to the boxes/ pallets.
   * @summary Create Inbound Shipment label
   * @param {FulfillmentApiCreateInboundShipmentLabelRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FulfillmentApi
   */
  public createInboundShipmentLabel(
    requestParameters: FulfillmentApiCreateInboundShipmentLabelRequest,
    options?: any
  ) {
    return FulfillmentApiFp(this.configuration)
      .createInboundShipmentLabel(
        requestParameters.shipmentId,
        requestParameters.authorization,
        requestParameters.wMSECACCESSTOKEN,
        requestParameters.wMQOSCORRELATIONID,
        requestParameters.wMSVCNAME,
        requestParameters.wMCONSUMERCHANNELTYPE,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Once you’ve converted items to WFS, you are ready to start shipping items inbound to Walmart. To do this, you will submit an Inbound shipment request. The Inbound shipment details when you expect to ship product, as well as the items and quantities which will be shipped.  Each shipment you send in to WFS should have a corresponding Inbound shipment. In this case, a shipment would be considered a direct truckload, LTL shipment, or set of items shipped via parcel on a given day.
   * @summary Create Inbound Shipment
   * @param {FulfillmentApiCreateShipmentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FulfillmentApi
   */
  public createShipment(
    requestParameters: FulfillmentApiCreateShipmentRequest,
    options?: any
  ) {
    return FulfillmentApiFp(this.configuration)
      .createShipment(
        requestParameters.authorization,
        requestParameters.wMSECACCESSTOKEN,
        requestParameters.wMQOSCORRELATIONID,
        requestParameters.wMSVCNAME,
        requestParameters.inlineObject,
        requestParameters.wMCONSUMERCHANNELTYPE,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * After Sellers request to create an Inbound Order, WFS may return error responses with error codes. Type of errors:  -  SKUs not in WFS catalog: Sellers need to make sure all SKUs have already been converted and added to the WFS catalog -  Missing required information;  -  Invalid Product ID (incorrect number of digits);  -  Duplicated Inbound Order ID: Inbound Order ID has already been used before -  Duplicated Product IDs Most of these errors can be prevented with a robust API integration that does not allow the mistakes to be made. Seller should update the request based on the error message and re-submit the request. Please note, once the Inbound Order is created successfully after the re-submission, historical errors under the same Inbound Order ID will be removed and no longer accessible.
   * @summary Get Inbound Shipment errors
   * @param {FulfillmentApiGetInboundOrderErrorsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FulfillmentApi
   */
  public getInboundOrderErrors(
    requestParameters: FulfillmentApiGetInboundOrderErrorsRequest,
    options?: any
  ) {
    return FulfillmentApiFp(this.configuration)
      .getInboundOrderErrors(
        requestParameters.authorization,
        requestParameters.wMSECACCESSTOKEN,
        requestParameters.wMQOSCORRELATIONID,
        requestParameters.wMSVCNAME,
        requestParameters.offset,
        requestParameters.limit,
        requestParameters.shipmentId,
        requestParameters.wMCONSUMERCHANNELTYPE,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers.  To retrieve the Shipment level info, please call the Get Inbound Shipments API and to get what needs to be in a specific shipment and SKU level receipt situation, please call the Get Inbound Shipment Items API
   * @summary Get Inbound Shipment Items
   * @param {FulfillmentApiGetInboundShipmentItemsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FulfillmentApi
   */
  public getInboundShipmentItems(
    requestParameters: FulfillmentApiGetInboundShipmentItemsRequest,
    options?: any
  ) {
    return FulfillmentApiFp(this.configuration)
      .getInboundShipmentItems(
        requestParameters.authorization,
        requestParameters.wMSECACCESSTOKEN,
        requestParameters.wMQOSCORRELATIONID,
        requestParameters.wMSVCNAME,
        requestParameters.offset,
        requestParameters.limit,
        requestParameters.shipmentId,
        requestParameters.wMCONSUMERCHANNELTYPE,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * After Sellers create an Inbound Order successfully, the response from Create Inbound Shipments API will tell whether the order can be sent in a single shipment to one WFS fulfillment center or needs to be split into multiple shipments to different fulfillment centers. To retrieve the Shipment level info, please call the Get Inbound Shipments API
   * @summary Get Shipments
   * @param {FulfillmentApiGetInboundShipmentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FulfillmentApi
   */
  public getInboundShipments(
    requestParameters: FulfillmentApiGetInboundShipmentsRequest,
    options?: any
  ) {
    return FulfillmentApiFp(this.configuration)
      .getInboundShipments(
        requestParameters.authorization,
        requestParameters.wMSECACCESSTOKEN,
        requestParameters.wMQOSCORRELATIONID,
        requestParameters.wMSVCNAME,
        requestParameters.offset,
        requestParameters.limit,
        requestParameters.inboundOrderId,
        requestParameters.shipmentId,
        requestParameters.status,
        requestParameters.fromCreateDate,
        requestParameters.toCreateDate,
        requestParameters.wMCONSUMERCHANNELTYPE,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Seller can modify the shipment quantity before the Shipment arrives at the WFS FCs. Seller cannot modify the shipment quantity when Shipment Status = Receiving in Progress, Closed, and Cancelled.   Seller will need to provide new quantities for each SKU to update. Seller will only be able to add up to 6 units per SKU but can reduce to 0 units to remove any SKU from a shipment. Seller cannot change all SKUs’ quantity to 0 – they must cancel the entire Inbound Order.
   * @summary Update Shipment Quantities
   * @param {FulfillmentApiUpdateShipmentQuantityRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FulfillmentApi
   */
  public updateShipmentQuantity(
    requestParameters: FulfillmentApiUpdateShipmentQuantityRequest,
    options?: any
  ) {
    return FulfillmentApiFp(this.configuration)
      .updateShipmentQuantity(
        requestParameters.authorization,
        requestParameters.wMSECACCESSTOKEN,
        requestParameters.wMQOSCORRELATIONID,
        requestParameters.wMSVCNAME,
        requestParameters.inlineObject3,
        requestParameters.wMCONSUMERCHANNELTYPE,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The purpose of this service is to capture tracking information from sellers. For small parcel shipments, sellers must provide the tracking info including carrier name and tracking numbers. WFS will use the data to capture updated expected delivery date to adjust the fulfillment inbound capacity to avoid any receiving delays.  Seller will also be able to view the updated expected delivery date through the Seller Center UI or calling the Get Inbound Shipment Items API.
   * @summary Update Shipment Tracking
   * @param {FulfillmentApiUpdateShipmentTrackingDetailsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FulfillmentApi
   */
  public updateShipmentTrackingDetails(
    requestParameters: FulfillmentApiUpdateShipmentTrackingDetailsRequest,
    options?: any
  ) {
    return FulfillmentApiFp(this.configuration)
      .updateShipmentTrackingDetails(
        requestParameters.authorization,
        requestParameters.wMSECACCESSTOKEN,
        requestParameters.wMQOSCORRELATIONID,
        requestParameters.wMSVCNAME,
        requestParameters.inlineObject1,
        requestParameters.wMCONSUMERCHANNELTYPE,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
